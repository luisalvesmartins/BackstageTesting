'use strict';

var metrics = require('../util/metrics.cjs.js');
var api = require('@opentelemetry/api');
var catalogModel = require('@backstage/catalog-model');

function initDatabaseMetrics(knex) {
  const seenProm = /* @__PURE__ */ new Set();
  const seen = /* @__PURE__ */ new Set();
  const meter = api.metrics.getMeter("default");
  return {
    entities_count_prom: metrics.createGaugeMetric({
      name: "catalog_entities_count",
      help: "Total amount of entities in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
      labelNames: ["kind"],
      async collect() {
        const result = await knex("refresh_state").select(
          "entity_ref"
        );
        const results = result.map((row) => row.entity_ref.split(":")[0]).reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), /* @__PURE__ */ new Map());
        results.forEach((value, key) => {
          seenProm.add(key);
          this.set({ kind: key }, value);
        });
        seenProm.forEach((key) => {
          if (!results.has(key)) {
            this.set({ kind: key }, 0);
            seenProm.delete(key);
          }
        });
      }
    }),
    registered_locations_prom: metrics.createGaugeMetric({
      name: "catalog_registered_locations_count",
      help: "Total amount of registered locations in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
      async collect() {
        const total = await knex("locations").count({
          count: "*"
        });
        this.set(Number(total[0].count));
      }
    }),
    relations_prom: metrics.createGaugeMetric({
      name: "catalog_relations_count",
      help: "Total amount of relations between entities. DEPRECATED: Please use opentelemetry metrics instead.",
      async collect() {
        const total = await knex("relations").count({
          count: "*"
        });
        this.set(Number(total[0].count));
      }
    }),
    entities_count: meter.createObservableGauge("catalog_entities_count", {
      description: "Total amount of entities in the catalog"
    }).addCallback(async (gauge) => {
      const result = await knex("refresh_state").select(
        "entity_ref"
      );
      const results = result.map((row) => catalogModel.parseEntityRef(row.entity_ref).kind).reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), /* @__PURE__ */ new Map());
      results.forEach((value, key) => {
        seen.add(key);
        gauge.observe(value, { kind: key });
      });
      seen.forEach((key) => {
        if (!results.has(key)) {
          gauge.observe(0, { kind: key });
          seen.delete(key);
        }
      });
    }),
    registered_locations: meter.createObservableGauge("catalog_registered_locations_count", {
      description: "Total amount of registered locations in the catalog"
    }).addCallback(async (gauge) => {
      const total = await knex("locations").count({
        count: "*"
      });
      gauge.observe(Number(total[0].count));
    }),
    relations: meter.createObservableGauge("catalog_relations_count", {
      description: "Total amount of relations between entities"
    }).addCallback(async (gauge) => {
      const total = await knex("relations").count({
        count: "*"
      });
      gauge.observe(Number(total[0].count));
    })
  };
}

exports.initDatabaseMetrics = initDatabaseMetrics;
//# sourceMappingURL=metrics.cjs.js.map
