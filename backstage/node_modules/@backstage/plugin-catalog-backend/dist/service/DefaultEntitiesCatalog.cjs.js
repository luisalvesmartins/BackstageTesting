'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var lodash = require('lodash');
var zod = require('zod');
var util = require('./util.cjs.js');

const defaultSortField = {
  field: "metadata.uid",
  order: "asc"
};
const DEFAULT_LIMIT = 20;
function parsePagination(input) {
  if (!input) {
    return {};
  }
  let { limit, offset } = input;
  if (input.after === void 0) {
    return { limit, offset };
  }
  let cursor;
  try {
    const json = Buffer.from(input.after, "base64").toString("utf8");
    cursor = JSON.parse(json);
  } catch {
    throw new errors.InputError("Malformed after cursor, could not be parsed");
  }
  if (cursor.limit !== void 0) {
    if (!Number.isInteger(cursor.limit)) {
      throw new errors.InputError("Malformed after cursor, limit was not an number");
    }
    limit = cursor.limit;
  }
  if (cursor.offset !== void 0) {
    if (!Number.isInteger(cursor.offset)) {
      throw new errors.InputError("Malformed after cursor, offset was not a number");
    }
    offset = cursor.offset;
  }
  return { limit, offset };
}
function stringifyPagination(input) {
  const { limit, offset } = input;
  const json = JSON.stringify({ limit, offset });
  const base64 = Buffer.from(json, "utf8").toString("base64");
  return base64;
}
function addCondition(queryBuilder, db, filter, negate = false, entityIdField = "entity_id") {
  const key = filter.key.toLowerCase();
  const values = filter.values?.map((v) => v.toLowerCase());
  const matchQuery = db("search").select("search.entity_id").where({ key }).andWhere(function keyFilter() {
    if (values?.length === 1) {
      this.where({ value: values.at(0) });
    } else if (values) {
      this.andWhere("value", "in", values);
    }
  });
  queryBuilder.andWhere(entityIdField, negate ? "not in" : "in", matchQuery);
}
function isEntitiesSearchFilter(filter) {
  return filter.hasOwnProperty("key");
}
function isOrEntityFilter(filter) {
  return filter.hasOwnProperty("anyOf");
}
function isNegationEntityFilter(filter) {
  return filter.hasOwnProperty("not");
}
function parseFilter(filter, query, db, negate = false, entityIdField = "entity_id") {
  if (isNegationEntityFilter(filter)) {
    return parseFilter(filter.not, query, db, !negate, entityIdField);
  }
  if (isEntitiesSearchFilter(filter)) {
    return query.andWhere(function filterFunction() {
      addCondition(this, db, filter, negate, entityIdField);
    });
  }
  return query[negate ? "andWhereNot" : "andWhere"](function filterFunction() {
    if (isOrEntityFilter(filter)) {
      for (const subFilter of filter.anyOf ?? []) {
        this.orWhere(
          (subQuery) => parseFilter(subFilter, subQuery, db, false, entityIdField)
        );
      }
    } else {
      for (const subFilter of filter.allOf ?? []) {
        this.andWhere(
          (subQuery) => parseFilter(subFilter, subQuery, db, false, entityIdField)
        );
      }
    }
  });
}
class DefaultEntitiesCatalog {
  database;
  logger;
  stitcher;
  constructor(options) {
    this.database = options.database;
    this.logger = options.logger;
    this.stitcher = options.stitcher;
  }
  async entities(request) {
    const db = this.database;
    let entitiesQuery = db("final_entities").select("final_entities.*");
    request?.order?.forEach(({ field }, index) => {
      const alias = `order_${index}`;
      entitiesQuery = entitiesQuery.leftOuterJoin(
        { [alias]: "search" },
        function search(inner) {
          inner.on(`${alias}.entity_id`, "final_entities.entity_id").andOn(`${alias}.key`, db.raw("?", [field]));
        }
      );
    });
    entitiesQuery = entitiesQuery.whereNotNull("final_entities.final_entity");
    if (request?.filter) {
      entitiesQuery = parseFilter(
        request.filter,
        entitiesQuery,
        db,
        false,
        "final_entities.entity_id"
      );
    }
    request?.order?.forEach(({ order }, index) => {
      if (db.client.config.client === "pg") {
        entitiesQuery = entitiesQuery.orderBy([
          { column: `order_${index}.value`, order, nulls: "last" }
        ]);
      } else {
        entitiesQuery = entitiesQuery.orderBy([
          { column: `order_${index}.value`, order: void 0, nulls: "last" },
          { column: `order_${index}.value`, order }
        ]);
      }
    });
    if (!request?.order) {
      entitiesQuery = entitiesQuery.leftOuterJoin(
        "refresh_state",
        "refresh_state.entity_id",
        "final_entities.entity_id"
      ).orderBy("refresh_state.entity_ref", "asc");
    } else {
      entitiesQuery.orderBy("final_entities.entity_id", "asc");
    }
    const { limit, offset } = parsePagination(request?.pagination);
    if (limit !== void 0) {
      entitiesQuery = entitiesQuery.limit(limit + 1);
    }
    if (offset !== void 0) {
      entitiesQuery = entitiesQuery.offset(offset);
    }
    let rows = await entitiesQuery;
    let pageInfo;
    if (limit === void 0 || rows.length <= limit) {
      pageInfo = { hasNextPage: false };
    } else {
      rows = rows.slice(0, -1);
      pageInfo = {
        hasNextPage: true,
        endCursor: stringifyPagination({
          limit,
          offset: (offset ?? 0) + limit
        })
      };
    }
    let entities = rows.map((e) => JSON.parse(e.final_entity));
    if (request?.fields) {
      entities = entities.map((e) => request.fields(e));
    }
    for (const entity of entities) {
      if (entity.relations) {
        for (const relation of entity.relations) {
          if (!relation.targetRef && relation.target) {
            relation.targetRef = catalogModel.stringifyEntityRef(relation.target);
          } else if (!relation.target && relation.targetRef) {
            relation.target = catalogModel.parseEntityRef(relation.targetRef);
          }
        }
      }
    }
    return {
      entities,
      pageInfo
    };
  }
  async entitiesBatch(request) {
    const lookup = /* @__PURE__ */ new Map();
    for (const chunk of lodash.chunk(request.entityRefs, 200)) {
      let query = this.database("final_entities").innerJoin(
        "refresh_state",
        "refresh_state.entity_id",
        "final_entities.entity_id"
      ).select({
        entityRef: "refresh_state.entity_ref",
        entity: "final_entities.final_entity"
      }).whereIn("refresh_state.entity_ref", chunk);
      if (request?.filter) {
        query = parseFilter(
          request.filter,
          query,
          this.database,
          false,
          "refresh_state.entity_id"
        );
      }
      for (const row of await query) {
        lookup.set(row.entityRef, row.entity ? JSON.parse(row.entity) : null);
      }
    }
    let items = request.entityRefs.map((ref) => lookup.get(ref) ?? null);
    if (request.fields) {
      items = items.map((e) => e && request.fields(e));
    }
    return { items };
  }
  async queryEntities(request) {
    const db = this.database;
    const limit = request.limit ?? DEFAULT_LIMIT;
    const cursor = {
      orderFields: [defaultSortField],
      isPrevious: false,
      ...parseCursorFromRequest(request)
    };
    const isFetchingBackwards = cursor.isPrevious;
    if (cursor.orderFields.length > 1) {
      this.logger.warn(`Only one sort field is supported, ignoring the rest`);
    }
    const sortField = {
      ...defaultSortField,
      ...cursor.orderFields[0]
    };
    const [prevItemOrderFieldValue, prevItemUid] = cursor.orderFieldValues || [];
    const dbQuery = db("final_entities").leftOuterJoin(
      "search",
      (qb) => qb.on("search.entity_id", "final_entities.entity_id").andOnVal("search.key", sortField.field)
    );
    if (cursor.filter) {
      parseFilter(
        cursor.filter,
        dbQuery,
        db,
        false,
        "final_entities.entity_id"
      );
    }
    const normalizedFullTextFilterTerm = cursor.fullTextFilter?.term?.trim();
    const textFilterFields = cursor.fullTextFilter?.fields ?? [sortField.field];
    if (normalizedFullTextFilterTerm) {
      if (textFilterFields.length === 1 && textFilterFields[0] === sortField.field) {
        dbQuery.andWhereRaw(
          "value like ?",
          `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
        );
      } else {
        const matchQuery = db("search").select("search.entity_id").whereIn("key", textFilterFields).andWhere(function keyFilter() {
          this.andWhereRaw(
            "value like ?",
            `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
          );
        });
        dbQuery.andWhere("final_entities.entity_id", "in", matchQuery);
      }
    }
    const countQuery = dbQuery.clone();
    const isOrderingDescending = sortField.order === "desc";
    if (prevItemOrderFieldValue) {
      dbQuery.andWhere(function nested() {
        this.where(
          "value",
          isFetchingBackwards !== isOrderingDescending ? "<" : ">",
          prevItemOrderFieldValue
        ).orWhere("value", "=", prevItemOrderFieldValue).andWhere(
          "final_entities.entity_id",
          isFetchingBackwards !== isOrderingDescending ? "<" : ">",
          prevItemUid
        );
      });
    }
    if (db.client.config.client === "pg") {
      dbQuery.orderBy([
        {
          column: "search.value",
          order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order,
          nulls: "last"
        },
        {
          column: "final_entities.entity_id",
          order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order
        }
      ]);
    } else {
      dbQuery.orderBy([
        {
          column: "search.value",
          order: void 0,
          nulls: "last"
        },
        {
          column: "search.value",
          order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order
        },
        {
          column: "final_entities.entity_id",
          order: isFetchingBackwards ? invertOrder(sortField.order) : sortField.order
        }
      ]);
    }
    if (util.isQueryEntitiesInitialRequest(request) && request.offset !== void 0) {
      dbQuery.offset(request.offset);
    }
    dbQuery.limit(isFetchingBackwards ? limit : limit + 1);
    countQuery.count("final_entities.entity_id", { as: "count" });
    const [rows, [{ count }]] = await Promise.all([
      limit > 0 ? dbQuery : [],
      // for performance reasons we invoke the countQuery
      // only on the first request.
      // The result is then embedded into the cursor
      // for subsequent requests.
      typeof cursor.totalItems === "undefined" ? countQuery : [{ count: cursor.totalItems }]
    ]);
    const totalItems = Number(count);
    if (isFetchingBackwards) {
      rows.reverse();
    }
    const hasMoreResults = limit > 0 && (isFetchingBackwards || rows.length > limit);
    if (rows.length > limit) {
      rows.length -= 1;
    }
    const isInitialRequest = cursor.firstSortFieldValues === void 0;
    const firstRow = rows[0];
    const lastRow = rows[rows.length - 1];
    const firstSortFieldValues = cursor.firstSortFieldValues || [
      firstRow?.value,
      firstRow?.entity_id
    ];
    const nextCursor = hasMoreResults ? {
      ...cursor,
      orderFieldValues: sortFieldsFromRow(lastRow),
      firstSortFieldValues,
      isPrevious: false,
      totalItems
    } : void 0;
    const prevCursor = !isInitialRequest && rows.length > 0 && !lodash.isEqual(sortFieldsFromRow(firstRow), cursor.firstSortFieldValues) ? {
      ...cursor,
      orderFieldValues: sortFieldsFromRow(firstRow),
      firstSortFieldValues: cursor.firstSortFieldValues,
      isPrevious: true,
      totalItems
    } : void 0;
    const items = rows.map((e) => JSON.parse(e.final_entity)).map((e) => request.fields ? request.fields(e) : e);
    return {
      items,
      pageInfo: {
        ...!!prevCursor && { prevCursor },
        ...!!nextCursor && { nextCursor }
      },
      totalItems
    };
  }
  async removeEntityByUid(uid) {
    const dbConfig = this.database.client.config;
    if (dbConfig.client.includes("mysql")) {
      const results = await this.database("refresh_state").select("entity_id").whereIn("entity_ref", function parents(builder) {
        return builder.from("refresh_state").innerJoin(
          "refresh_state_references",
          {
            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
          }
        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
      });
      await this.database("refresh_state").update({
        result_hash: "child-was-deleted",
        next_update_at: this.database.fn.now()
      }).whereIn(
        "entity_id",
        results.map((key) => key.entity_id)
      );
    } else {
      await this.database("refresh_state").update({
        result_hash: "child-was-deleted",
        next_update_at: this.database.fn.now()
      }).whereIn("entity_ref", function parents(builder) {
        return builder.from("refresh_state").innerJoin(
          "refresh_state_references",
          {
            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
          }
        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
      });
    }
    const relationPeers = await this.database.from("relations").innerJoin("refresh_state", {
      "refresh_state.entity_ref": "relations.target_entity_ref"
    }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.target_entity_ref" }).union(
      (other) => other.from("relations").innerJoin("refresh_state", {
        "refresh_state.entity_ref": "relations.source_entity_ref"
      }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.source_entity_ref" })
    );
    await this.database("refresh_state").where("entity_id", uid).delete();
    await this.stitcher.stitch({
      entityRefs: new Set(relationPeers.map((p) => p.ref))
    });
  }
  async entityAncestry(rootRef) {
    const [rootRow] = await this.database("refresh_state").leftJoin("final_entities", {
      "refresh_state.entity_id": "final_entities.entity_id"
    }).where("refresh_state.entity_ref", "=", rootRef).select({
      entityJson: "final_entities.final_entity"
    });
    if (!rootRow) {
      throw new errors.NotFoundError(`No such entity ${rootRef}`);
    }
    const rootEntity = JSON.parse(rootRow.entityJson);
    const seenEntityRefs = /* @__PURE__ */ new Set();
    const todo = new Array();
    const items = new Array();
    for (let current = rootEntity; current; current = todo.pop()) {
      const currentRef = catalogModel.stringifyEntityRef(current);
      seenEntityRefs.add(currentRef);
      const parentRows = await this.database(
        "refresh_state_references"
      ).innerJoin("refresh_state", {
        "refresh_state_references.source_entity_ref": "refresh_state.entity_ref"
      }).innerJoin("final_entities", {
        "refresh_state.entity_id": "final_entities.entity_id"
      }).where("refresh_state_references.target_entity_ref", "=", currentRef).select({
        parentEntityRef: "refresh_state.entity_ref",
        parentEntityJson: "final_entities.final_entity"
      });
      const parentRefs = [];
      for (const { parentEntityRef, parentEntityJson } of parentRows) {
        parentRefs.push(parentEntityRef);
        if (!seenEntityRefs.has(parentEntityRef)) {
          seenEntityRefs.add(parentEntityRef);
          todo.push(JSON.parse(parentEntityJson));
        }
      }
      items.push({
        entity: current,
        parentEntityRefs: parentRefs
      });
    }
    return {
      rootEntityRef: catalogModel.stringifyEntityRef(rootEntity),
      items
    };
  }
  async facets(request) {
    const facets = {};
    const db = this.database;
    for (const facet of request.facets) {
      const dbQuery = db("search").where("search.key", facet.toLocaleLowerCase("en-US")).whereNotNull("search.original_value").select({ value: "search.original_value", count: db.raw("count(*)") }).groupBy("search.original_value");
      if (request?.filter) {
        parseFilter(request.filter, dbQuery, db, false, "search.entity_id");
      }
      const result = await dbQuery;
      facets[facet] = result.map((data) => ({
        value: String(data.value),
        count: Number(data.count)
      }));
    }
    return { facets };
  }
}
const entityFilterParser = zod.z.lazy(
  () => zod.z.object({
    key: zod.z.string(),
    values: zod.z.array(zod.z.string()).optional()
  }).or(zod.z.object({ not: entityFilterParser })).or(zod.z.object({ anyOf: zod.z.array(entityFilterParser) })).or(zod.z.object({ allOf: zod.z.array(entityFilterParser) }))
);
zod.z.object({
  orderFields: zod.z.array(
    zod.z.object({ field: zod.z.string(), order: zod.z.enum(["asc", "desc"]) })
  ),
  orderFieldValues: zod.z.array(zod.z.string().or(zod.z.null())),
  filter: entityFilterParser.optional(),
  isPrevious: zod.z.boolean(),
  query: zod.z.string().optional(),
  firstSortFieldValues: zod.z.array(zod.z.string().or(zod.z.null())).optional(),
  totalItems: zod.z.number().optional()
});
function parseCursorFromRequest(request) {
  if (util.isQueryEntitiesInitialRequest(request)) {
    const {
      filter,
      orderFields: sortFields = [defaultSortField],
      fullTextFilter
    } = request;
    return { filter, orderFields: sortFields, fullTextFilter };
  }
  if (util.isQueryEntitiesCursorRequest(request)) {
    return request.cursor;
  }
  return {};
}
function invertOrder(order) {
  return order === "asc" ? "desc" : "asc";
}
function sortFieldsFromRow(row) {
  return [row.value, row.entity_id];
}

exports.DefaultEntitiesCatalog = DefaultEntitiesCatalog;
//# sourceMappingURL=DefaultEntitiesCatalog.cjs.js.map
