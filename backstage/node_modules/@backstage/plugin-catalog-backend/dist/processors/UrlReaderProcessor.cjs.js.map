{"version":3,"file":"UrlReaderProcessor.cjs.js","sources":["../../src/processors/UrlReaderProcessor.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { assertError } from '@backstage/errors';\nimport limiterFactory, { Limit } from 'p-limit';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport parseGitUrl from 'git-url-parse';\nimport {\n  CatalogProcessor,\n  CatalogProcessorCache,\n  CatalogProcessorEmit,\n  CatalogProcessorEntityResult,\n  CatalogProcessorParser,\n  CatalogProcessorResult,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\nimport { LoggerService, UrlReaderService } from '@backstage/backend-plugin-api';\n\nconst CACHE_KEY = 'v1';\n\n// WARNING: If you change this type, you likely need to bump the CACHE_KEY as well\ntype CacheItem = {\n  etag: string;\n  value: {\n    type: 'entity';\n    entity: Entity;\n    location: LocationSpec;\n  }[];\n};\n\n/** @public */\nexport class UrlReaderProcessor implements CatalogProcessor {\n  // This limiter is used for only consuming a limited number of read streams\n  // concurrently.\n  #limiter: Limit;\n\n  constructor(\n    private readonly options: {\n      reader: UrlReaderService;\n      logger: LoggerService;\n    },\n  ) {\n    this.#limiter = limiterFactory(5);\n  }\n\n  getProcessorName() {\n    return 'url-reader';\n  }\n\n  async readLocation(\n    location: LocationSpec,\n    optional: boolean,\n    emit: CatalogProcessorEmit,\n    parser: CatalogProcessorParser,\n    cache: CatalogProcessorCache,\n  ): Promise<boolean> {\n    if (location.type !== 'url') {\n      return false;\n    }\n\n    const cacheItem = await cache.get<CacheItem>(CACHE_KEY);\n\n    try {\n      const { response, etag: newEtag } = await this.doRead(\n        location.target,\n        cacheItem?.etag,\n      );\n\n      const parseResults: CatalogProcessorResult[] = [];\n      for (const item of response) {\n        for await (const parseResult of parser({\n          data: item.data,\n          location: { type: location.type, target: item.url },\n        })) {\n          parseResults.push(parseResult);\n          emit(parseResult);\n        }\n      }\n\n      const isOnlyEntities = parseResults.every(r => r.type === 'entity');\n      if (newEtag && isOnlyEntities) {\n        await cache.set<CacheItem>(CACHE_KEY, {\n          etag: newEtag,\n          value: parseResults as CatalogProcessorEntityResult[],\n        });\n      }\n\n      emit(processingResult.refresh(`${location.type}:${location.target}`));\n    } catch (error) {\n      assertError(error);\n      const message = `Unable to read ${location.type}, ${error}`.substring(\n        0,\n        5000,\n      );\n      if (error.name === 'NotModifiedError' && cacheItem) {\n        for (const parseResult of cacheItem.value) {\n          emit(parseResult);\n        }\n        emit(processingResult.refresh(`${location.type}:${location.target}`));\n        await cache.set(CACHE_KEY, cacheItem);\n      } else if (error.name === 'NotFoundError') {\n        if (!optional) {\n          emit(processingResult.notFoundError(location, message));\n        }\n      } else {\n        emit(processingResult.generalError(location, message));\n      }\n    }\n\n    return true;\n  }\n\n  private async doRead(\n    location: string,\n    etag?: string,\n  ): Promise<{ response: { data: Buffer; url: string }[]; etag?: string }> {\n    // Does it contain globs? I.e. does it contain asterisks or question marks\n    // (no curly braces for now)\n\n    const { filepath } = parseGitUrl(location);\n    if (filepath?.match(/[*?]/)) {\n      const response = await this.options.reader.search(location, { etag });\n      const output = response.files.map(async file => ({\n        url: file.url,\n        data: await this.#limiter(file.content),\n      }));\n      return { response: await Promise.all(output), etag: response.etag };\n    }\n\n    const data = await this.options.reader.readUrl(location, { etag });\n    return {\n      response: [{ url: location, data: await data.buffer() }],\n      etag: data.etag,\n    };\n  }\n}\n"],"names":["limiterFactory","processingResult","assertError","parseGitUrl"],"mappings":"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"}